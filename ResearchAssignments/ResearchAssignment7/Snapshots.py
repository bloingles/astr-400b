def snapshotGen(
        maxStep:int,
        minStep:int,
        first:int,
        last:int,
        focus:int,
        buff:int
) -> list[int]:
    """
    This function is called from snapshotGen and generates the values of the list
    to the left focus value if minStep and maxStep are negative and to the right
    of the focus value if minStep and maxStep are positive.

    Arguments:
        maxStep: the maximum interval between snapshots
        minStep: the minimum interval between snapshots 
        first: the first snapshot
        last: the last snapshot
        foci: the key snapshots around which to consider smaller intervals
              between snapshots
        buff: the number of steps to the right of a particular focus with
              the finest interval size
    Returns:
        snapshots: a list of snapshots to the left or right of the focus
    """
    snapshots:list[int] = [focus] 
    snapshot:int = focus # used to add snapshots

    # Adds the initial buffer of the minimum interval
    for _ in range(buff):
        if snapshot + minStep > last or snapshot + minStep < first:
            break
        snapshot += minStep
        snapshots.append(snapshot)

    # double the interval size until step = maxStep
    step:int = 2*minStep
    while abs(step) < abs(maxStep) and first <= snapshot+step <= last:
        # Prevents adding values higher than 'last' or lower than 'first'
        for _ in range(max(1,buff//2)): # Ensures snapshot is always decremented
            if snapshot + step > last or snapshot + step < first:
                break
            snapshot += step
            snapshots.append(snapshot)
        step *=2

    # increment snapshot by multiples of maxSize until you reach last
    while first <= snapshot + maxStep <= last:
        snapshot += maxStep
        if snapshot % maxStep != 0:
            snapshot -= (maxStep+snapshot%abs(maxStep)) # this allows all the values
        snapshots.append(snapshot)                 # generated by the foci to line
                                                   # up and cancel
    return sorted(set(snapshots)) # sorts list and removes duplicate values

def snapshotsCompile(
        coarseness:int,
        fineness:int = 0,
        first:int = 0,
        last:int = 801,
        foci:tuple[int,...] = (275,410,470), # 3.929 Gyr, # 5.857 Gyr, # 6.714 Gyr
        prep:int = 2,
        lag:int = 6
) -> tuple[int,...]:
    """
    This function accepts specifications on which snapshots the user
    wants to analyze and generates the full list as a tuple. It also
    finds snapshots halfway between the focus values for detailed
    analysis.

    Arguments:
        coarseness: log_2(size), where 'size' denotes the maximum interval
                    between snapshots
        fineness: log_2(size), where 'size' denotes the minimum interval
                    between snapshots 
        first: the first snapshot
        last: the last snapshot
        foci: the key snapshots around which to consider smaller intervals
              between snapshots
        prep: the number of steps to the left of a particular focus with
              the finest interval size
        buffer: the number of steps to the right of a particular focus
                with the finest interval size
    Returns:
        snapshots: a tuple of snapshots on which to calculate the bar strength
        majors: a tuple of snapshots on which to perform detailed analysis
    """
    maxStep:int = 2**int(coarseness)
    minStep:int = 2**int(fineness)
    foci = tuple(sorted(foci))
    ssSet:set[None|int] = set()
    
    # from first to left focus
    farLeft = snapshotGen(-maxStep,-minStep,first,last,foci[0],prep)
    ssSet.update(farLeft)
    
    for i, focus in enumerate(foci):
        # from focus to last
        right = snapshotGen(maxStep,minStep,first,last,focus,lag)
        if i < len(foci) - 1: # between foci
            left = snapshotGen(-maxStep,-minStep,focus,last,foci[i+1],prep)
            segment = set(right).union(left) # remove redundant snapshots
            ssSet.update(segment)
        else: # no inbetween region here
            ssSet.update(right)
    ssSet.add(last-1)
    snapshots:tuple[int,...] = tuple(sorted(ssSet))
    return snapshots
